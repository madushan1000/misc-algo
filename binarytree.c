//binarytree.c E/10/389#include <stdio.h>#include <stdlib.h>typedef struct nnode *node;struct nnode{int data;node left;node right;};node newNode(int data);void insert(node root,int data);void printTree(node,int,int);node search(node root,int data);node findmax(node root);node findmin(node root);void remove_node(node root,node prev,int data,int n);void replacePC(node root,node prev,node next);int main(){	node root=newNode(38);	insert(root,35);	insert(root,1);	insert(root,5);	insert(root,100);	insert(root,11);	insert(root,13);	insert(root,25);	insert(root,40);	insert(root,50);	insert(root,55);	insert(root,51);	insert(root,39);	int i;	for(i=0;i<10;i++)	{		printTree(root,0,i);		printf("\n");	}	printf("%d\n",search(root,1)->data);	printf("%d\n",findmax(root)->data);	printf("%d\n\n\n",findmin(root)->data);	remove_node(root,NULL,51,0);	for(i=0;i<10;i++)	{		printTree(root,0,i);		printf("\n");	}	return 0;}void insert(node root,int data){	if(root->data > data) //checking if the given value is less or greater than the root->data value	{		if(root->left) 		{			insert(root->left,data); //if less goto to the left node		}		else		{			node new=newNode(data);			root->left =new; //if there is no left node make one and add the value		}	}	else if(root->data < data)	{		if(root->right)		{			insert(root->right,data);//if greater goto to the right node		}		else		{			node new=newNode(data);			root->right =new; //if there is no right node make one and add the value		}	}}node search(node root,int data){	if(root->data > data) //checking if the given value is less or greater than the root->data value	{		if(root->left)		{			//printf("%d \n",root->data);			return search(root->left,data); //if less goto to the left node		}	}	else if(root->data < data)	{		if(root->right)		{			//printf("%d\n",root->data);			return search(root->right,data); //if greater goto to the left node		}	}	else if(root->data == data)		return root; //if equal return the currant node	return NULL;}node findmax(node root){	while(root->right)	{		root=root->right; //goto right until the last node	}	return root;}node findmin(node root){	while(root->left)	{	root=root->left; //goto left until the last node	}	return root;}void remove_node(node root,node prev,int data,int n){	if(root->data > data) //checking if the given value is less or greater than the root->data value	{		if(root->left)		{			remove_node(root->left,root,data,0); 		}	}	else if(root->data < data)	{		if(root->right)		{			remove_node(root->right,root,data,1); 		}	}	else if(root->data == data)	{		if(root->left && root->right)		{			node tmp = findmin(root->right);			root->data=tmp->data;			remove_node(tmp,prev,tmp->data,0);		}		else if(root->left)		{			replacePC(root,prev,root->left);		}		else if(root->right)		{			replacePC(root,prev,root->right);		}		else		{			replacePC(root,prev,NULL);		}	}}void replacePC(node root,node prev,node next){	if(prev)	{		if(prev->left && root->data==prev->left->data)		{			prev->left=next;			free(root);		}		else if(prev->right && root->data==prev->right->data)		{						prev->right=next;			free(root);		}	}	else if(next)	{		prev=next;	}}node newNode(int data){	node new = malloc(sizeof(struct nnode)); //memory allocation	new->left=NULL; //assigning child nodes to NULL	new->right=NULL;	new->data=data; //assigning data value to ->data	return new; //return new node}void printTree(node root,int level,int nlvl){	if(root)	{		printTree(root->left,level+1,nlvl);		if(level==nlvl) printf("%d ",root->data);		printTree(root->right,level+1,nlvl);	}}